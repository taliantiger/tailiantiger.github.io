<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post3s on Talian</title>
    <link>https://taliantiger.github.io/post3/</link>
    <description>Recent content in Post3s on Talian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Apr 2020 09:56:11 +0800</lastBuildDate>
    
	<atom:link href="https://taliantiger.github.io/post3/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>正确的刷牙方法</title>
      <link>https://taliantiger.github.io/post3/%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%88%B7%E7%89%99%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 01 Apr 2020 09:56:11 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%88%B7%E7%89%99%E6%96%B9%E6%B3%95/</guid>
      <description>正确的刷牙方法  一个月前吃橘子的时候，橘子比较酸，但没有在意，等吃了很多个时，忽然觉得牙齿 一阵酸痛，用镜子看了看牙齿，发现左边的一颗牙龈比右边对称的牙龈萎缩了些，牙齿多露出了1.5毫米，用手一碰 露出的牙齿，就会一阵酸痛，当时以为是橘子腐蚀了，就一直不再吃橘子，但也没有深究。
 昨天突发奇想，查了查知乎牙龈萎缩相关资料，发现大部分观点是牙龈萎缩后基本 无法复原了，除做昂贵的手术或用其它物体把露出的牙齿粘上。再接着找资料，寻找牙龈萎缩的原因，发现自己的刷牙 方法从小就不太规范，虽然会斜着刷，但用的力度太大，以前经常刷牙刷出血&amp;hellip;&amp;hellip;没有完全按照巴氏刷牙法执行。同时我从大学开始， 牙刷就用的是中毛，可中毛和硬毛对牙龈有比较重的损伤，用软毛才比较合适。
 如果再不用正确的刷牙方法刷牙，估计就是严重的牙齿楔形，很难再修复了， 我的一颗牙齿已经有点楔形了，保护牙齿，还是早发现，早纠正。现实生活上也仿佛如此，表面上平平 安安，健康无事，但是很多风险与疾病就隐藏在暗处，真正的危险，往往也都是藏在暗处，就连国家，都无法 提前知道疾病会爆发，只能在疫情爆发后解决问题。我们有时也无法发现生活中所有的风险，能做的，只能是 在风险出现时，及时调整解决。虽然牙齿萎缩，很难恢复，但是从发现问题开始，好好好珍惜尚存完好的牙齿， 采取正确的刷牙方法，不让萎缩的牙齿接着严重下去，才是我当下要关注的事。
 给岁月以文明，而不是给文明以岁月。给牙齿恰当的保护，而不是损坏时的手术。
 牙齿楔形
正确刷牙法</description>
    </item>
    
    <item>
      <title>Leetcode例题_05</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_05/</link>
      <pubDate>Wed, 01 Apr 2020 09:48:03 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_05/</guid>
      <description>最长回文子串   给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
输入: &amp;ldquo;babad&amp;rdquo; 输出: &amp;ldquo;bab&amp;rdquo; 注意: &amp;ldquo;aba&amp;rdquo; 也是一个有效答案。
示例 2：
输入: &amp;ldquo;cbbd&amp;rdquo; 输出: &amp;ldquo;bb&amp;rdquo;
   Python  基础暴力解法（有待研究）：  class Solution: # 暴力匹配（超时） def longestPalindrome(self, s: str) -&amp;gt; str: # 特判 size = len(s) if size &amp;lt; 2: return s max_len = 1 res = s[0] # 枚举所有长度大于等于 2 的子串 for i in range(size - 1): for j in range(i + 1, size): if j - i + 1 &amp;gt; max_len and self.</description>
    </item>
    
    <item>
      <title>Leetcode习题_04</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_04/</link>
      <pubDate>Tue, 31 Mar 2020 11:17:34 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_04/</guid>
      <description>寻找两个有序数组的中位数:   给定两个大小为m和n的有序数组 nums1 和 nums2 。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。   Python 想起之前书中例题，于是尝试：  利用pop( )语句，把nums2列表末尾元素“吹”出来； 再利用append() 语句，把列表元素“压”回到nums1[]中。 利用list.sort()排序。 再判断元素总个数的奇偶情况，分不同情况取中位数即可。  class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&amp;gt; float:	def paixu(nums1,nums2): while nums2: a = nums2.pop() nums1.append(a) nums1.sort() return nums1 def test_length(nums1): len_1 = len(nums1) return len_1 def panduanshu(nums1,len_1): middle = len_1//2 if (len_1%2==0): result = (nums1[middle] + nums1[middle-1])/2 else : result = nums1[middle] return result #nums1=paixu(nums1,nums2) #len_1=test_length(nums1) #result=panduanshu(nums1,len_1) return panduanshu(nums1,test_length(paixu(nums1,nums2))) #尝试不定义变量，直接嵌套调用,发现复杂的没变化。 </description>
    </item>
    
    <item>
      <title>Java学习,何时开始使用IDE工具</title>
      <link>https://taliantiger.github.io/post3/java%E5%AD%A6%E4%B9%A0%E4%BD%95%E6%97%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8ide%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 30 Mar 2020 22:49:29 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/java%E5%AD%A6%E4%B9%A0%E4%BD%95%E6%97%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8ide%E5%B7%A5%E5%85%B7/</guid>
      <description>Java学习，何时开始使用IDE工具呢？  标准是：如果你还离不开这个IDE工具，那么你就不能用这个IDE工具;只有 当你十分清楚再IDE工具里单击每一个菜单，单击每一个按钮&amp;hellip;&amp;hellip;IDE在底层 为你做的每个细节时，才可以使用IDE工具！  选自《疯狂Java讲义》
 仔细想想，挺有道理的，要想成为一名合格的程序员，我们必须要清楚地知道 软件每一步在细节上到底做了什么，知道事物的本质，才能更好的创造。就像 《三体》一样，看哪个文明的更厉害，就看哪个文明在微观之处研究得更深入 ，研究越细，越能了解事物得本质，创造更厉害得本质。
今天刚读完这本《疯狂Java讲义》第一章， 在第一章提到了很多Java运行的细节: “编写” xxx.java 文件=》 javac 命令 “编译”.java文件，生成 xxx.class （类文件）=》 java 命令 “运行” xxx （类的名字）　．．．之类的运行步骤。还有classpath环境变量设置的 本质就是————JRE在设定的路径下搜索Java类。</description>
    </item>
    
    <item>
      <title>Leetcode习题_03</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_03/</link>
      <pubDate>Mon, 30 Mar 2020 12:53:00 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_03/</guid>
      <description>无重复字符的最长子串   给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: &amp;ldquo;abcabcbb&amp;rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。
   Python:  解题方法：利用动态规划求解:把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解  class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: if s == &amp;#39;&amp;#39;: return 0 if len(s) == 1: return 1 def find_left(s, i): tmp_str = s[i] j = i - 1 while j &amp;gt;= 0 and s[j] not in tmp_str: tmp_str += s[j] j -= 1 return len(tmp_str) length = 0 for i in range(0, len(s)): length = max(length, find_left(s, i)) return length  来源：leetcode</description>
    </item>
    
    <item>
      <title>Python_9_4例题</title>
      <link>https://taliantiger.github.io/post3/python_9_4%E4%BE%8B%E9%A2%98/</link>
      <pubDate>Sun, 29 Mar 2020 22:54:55 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/python_9_4%E4%BE%8B%E9%A2%98/</guid>
      <description>又到周日了，仔细算算，看《python编程从入门到实践》学python已经有半个月了，还有2/3没看完，打算以后周五周末周日再看了。前天我的 《疯狂Java讲义》和《剑指offer》到了，打算工作日都主要研究Java为主，先把Java基础打好，才有更强大的工作资本。    9_4 就餐人数：
在为完成练习1胜9负而编写的程序中,添加一个名为服务数量的属性,并将其默认值设置为0,根据这个类创建一个名为 餐厅的实例;打印有多少人在这家餐馆就餐过,然后修改这个值并再次打印它。
添加一个名为设置数量为()的方法,它让你能够设置就餐人数。调用这个方法并向它传递一个值,然后再次打印这个值。
添加一个名为增加数量为()的方法,它让你能够将就餐人数递增。调用这个方法并向它传递一个这样的值:你认为这家餐馆每天可能接待的就餐人数。   class Restaurant(): #定义一个类 def __init__(self,restaurant_name,cuisine_type): #记住这里__init__的下划线是左右各两条__，而不是一条_ self.restaurant_name = restaurant_name self.cuisine_type = cuisine_type self.number_served = 0 #特殊方法下面的选项开头之前，都要添加“self”，代表默认 def describe_restaurant(self): print(self.restaurant_name.title() + &amp;#34; is a very good restaurant.&amp;#34;) print(self.cuisine_type.title() + &amp;#34; is very tasty food for most people.&amp;#34;) def open_restaurant(self): #不知道为什么，复制粘贴过来就出错 ==&amp;gt;复制到之前的地方，对比下，就很明显，发现： “语法错误”，第9行复制过来后，没发现，print结尾少了括号。 print(&amp;#34;Our restaurant is opening&amp;#34;) def read_number_served(self):	#打印一条支出多少人用餐的消息 print(&amp;#34;This restaurant has &amp;#34; + str(self.number_served) + &amp;#34; person will eat food.</description>
    </item>
    
    <item>
      <title>Leetcode习题_02</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_02/</link>
      <pubDate>Sun, 29 Mar 2020 10:57:59 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_02/</guid>
      <description>两数之和_02   给定两个 非空 链表来表示两个非负整数。位数按照 逆序 方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。
你可以假设除了数字 0 之外，这两个数字都不会以零开头。
示例：
输入： (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) 输出： 7 -&amp;gt; 0 -&amp;gt; 8 原因： 342 + 465 = 807
   Java:  public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q !</description>
    </item>
    
    <item>
      <title>多个实参输入一个形参中</title>
      <link>https://taliantiger.github.io/post3/%E5%A4%9A%E4%B8%AA%E5%AE%9E%E5%8F%82%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%BD%A2%E5%8F%82/</link>
      <pubDate>Sat, 28 Mar 2020 17:46:13 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E5%A4%9A%E4%B8%AA%E5%AE%9E%E5%8F%82%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%BD%A2%E5%8F%82/</guid>
      <description> 8-12 三明治：编写一个函数，它接受顾客要在三明治中添加的一系列食材 这函数只有一个形参(它收集函数调用中提供的所有食材),并打印一条消 息，对顾客雨酌三明治进行概述。调用这个函数三次，每次都提供不同数量的实参    函数注意事项：函数调用的多个形参，必须是一系列字符串元素，而不能是自己定义的列表变量！！   def accept_food( *somefood ):for somefood_1 in somefood :print(&amp;#34;- &amp;#34; + somefood_1)print(&amp;#39;\n&amp;#39;)accept_food(&amp;#39;a&amp;#39;) #函数这里调用的形参，必须是字符串元素，而不能是自己定义的列表变量！！ accept_food(&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;)accept_food(&amp;#39;d&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;f&amp;#39;)# ~ def make_pizza(*toppings):  # ~ print(&amp;#34;\nMaking a pizza with the following toppings:&amp;#34;)  # ~ for topping in toppings:  # ~ print(&amp;#34;- &amp;#34; + topping)  # ~ make_pizza(&amp;#39;pepperoni&amp;#39;)  # ~ make_pizza(&amp;#39;mushrooms&amp;#39;, &amp;#39;green peppers&amp;#39;, &amp;#39;extra cheese&amp;#39;) </description>
    </item>
    
    <item>
      <title>python:利用切片禁止函数修改列表</title>
      <link>https://taliantiger.github.io/post3/%E5%88%A9%E7%94%A8%E5%88%87%E7%89%87%E7%A6%81%E6%AD%A2%E5%87%BD%E6%95%B0%E4%BF%AE%E6%94%B9%E5%88%97%E8%A1%A8/</link>
      <pubDate>Sat, 28 Mar 2020 16:44:34 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E5%88%A9%E7%94%A8%E5%88%87%E7%89%87%E7%A6%81%E6%AD%A2%E5%87%BD%E6%95%B0%E4%BF%AE%E6%94%B9%E5%88%97%E8%A1%A8/</guid>
      <description> 8-11不变的魔术师:修改你为完成练习8-10而编写的程序,在调用函数make great()时,向它传递魔术师列表的副本。由于 不想修改原始列表, 请返回修改后的列表，并将其存储到另一个列表中。分别使用这两个列表来调用showmagicians(),确认一个列表包含的是原来的魔木师名字,而另一个列表包含的是添加了字样&amp;quot;theGreat&amp;quot;的魔术师名字。   函数核心关键:在调用函数输出时，函数的实参末尾加上切片 [:] ,相当于为函数创建了副本，这样函数原本的列表值就不会被改变了。  #定义“显示具体打印过程”的函数 ==》在函数中修改列表的模板 def print_magicians(unprinted_magicians_names,completed_magicians): while unprinted_magicians_names: current_magician = unprinted_magicians_names.pop() #每打印完一个，除去掉“未打印列表”中的一个元素 print(&amp;#34;Printing magicians: &amp;#34; + current_magician) completed_magicians.append(current_magician) #每打完一个，就把被打印的append保存在之前的空列表中 #定义“显示打印结果”的函数 def show_completed_magicians(completed_magicians): print(&amp;#34;\nThe following magicians have been printed:&amp;#34;) for completed_magician in completed_magicians: print(completed_magician) def make_great(completed_magicians,completed_magicians_2): print(&amp;#34;\nThe following magicians is new&amp;#34;) while completed_magicians: current_magician_2=&amp;#34;the Great &amp;#34; + completed_magicians.pop() #类似重复第一个函数，pop一个函数的列表，加入另外一个函数的列表 completed_magicians_2.append(current_magician_2) for completed_magician_2 in completed_magicians_2: print(completed_magician_2) unprinted_magicians_names=[&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;D&amp;#39;] completed_magicians=[] completed_magicians_2=[] print_magicians(unprinted_magicians_names[:],completed_magicians) #调用函数时，在实参这里添加 切片[:] ，就可以达到调用副本的目的 show_completed_magicians(completed_magicians) make_great(completed_magicians,completed_magicians_2) print(completed_magicians_2) #显示出添加“the Great” 后的结果 print(unprinted_magicians_names) </description>
    </item>
    
    <item>
      <title>《python编程从入门到实践》8_10例题</title>
      <link>https://taliantiger.github.io/post3/python_8_10%E4%BE%8B%E9%A2%98/</link>
      <pubDate>Sat, 28 Mar 2020 15:49:10 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/python_8_10%E4%BE%8B%E9%A2%98/</guid>
      <description>##《python编程从入门到实践》例题
 8-9 魔术师： 创建一个包含魔术师名字的列表，并将其传递给一个名为 show_magicians() 的函数，这个函数打印列表中每个函数的名字 8-10 了不起的魔术师：在你为完成练习 8—9 而编写的程序中，编写一个名为make_great()的函数，对魔术师列表进行修改，在每个魔术师的名字中都加入字样： the Great“。 调用函数show_magician,确认列表确实变了   构造函数关键: 函数（形参A，形参B），把形参A的列表pop出，再append到形参B的列表  def print_magicians(unprinted_magicians_names,completed_magicians): #定义“显示具体打印过程”的函数 ==》在函数中修改列表的模板 while unprinted_magicians_names: current_magician = unprinted_magicians_names.pop() #每打印完一个，除去掉“未打印列表”中的一个元素 print(&amp;#34;Printing magicians: &amp;#34; + current_magician) completed_magicians.append(current_magician) #每打完一个，就把被打印的append保存在之前的空列表中 #定义“显示打印结果”的函数 def show_completed_magicians(completed_magicians): print(&amp;#34;\nThe following magicians have been printed:&amp;#34;) for completed_magician in completed_magicians: print(completed_magician) def make_great(completed_magicians,completed_magicians_2): print(&amp;#34;\nThe following magicians is new&amp;#34;) while completed_magicians: current_magician_2=&amp;#34;the Great &amp;#34; + completed_magicians.pop() #类似重复第一个函数，pop一个函数的列表，加入另外一个函数的列表 completed_magicians_2.append(current_magician_2) for completed_magician_2 in completed_magicians_2: print(completed_magician_2) unprinted_magicians_names=[&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;D&amp;#39;] completed_magicians=[] completed_magicians_2=[] print_magicians(unprinted_magicians_names,completed_magicians) show_completed_magicians(completed_magicians) make_great(completed_magicians,completed_magicians_2) print(completed_magicians_2) #显示出添加“the Great” 后的结果 </description>
    </item>
    
    <item>
      <title>Leetcode习题_01</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_01/</link>
      <pubDate>Sat, 28 Mar 2020 08:59:32 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_01/</guid>
      <description>1.两数之和   给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
  你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
  示例:
给定 nums = [2, 7, 11, 15], target = 9,因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1]
   方法一:暴力法 遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。
Java:
class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i &amp;lt; nums.length; i++) { for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>Hugo建立博客用到的代码</title>
      <link>https://taliantiger.github.io/post3/hugo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%88%B0%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 27 Mar 2020 13:36:13 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/hugo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%88%B0%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
      <description>hugo建立博客用到的代码   前几天看了b站的程序羊的教学视频，学会了搭建个人博客。配置完git和hugo环境后，用到了很多git命令，现在在这里把后几步的git命令记录在这篇博客当中  建立好hugo和git环境后的前提下,在cmd中 1:输入代码 hugo new site myblog3 (myblog3是我自己的命名的一个例子)
 2:输入代码 git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c (这里的theme主题可以自己在网站上找，我这里是程序羊推荐的)
再输入代码 hugo server -t m10c --buildDrafts（在本地host先建立博客）
 3:输入代码 hugo new post3/blog3.md (创建 文件夹post（自己命名），同时在建立博客.md文件（blog3也是自己命名的）)
 4:输入代码 hugo --theme=m10c --baseUrl=&amp;quot;https://taliantiger.github.io/&amp;quot; --buildDrafts(用于建立public文件，其中&amp;quot;https://taliantiger.github.io/&amp;ldquo;填写你是自己之前建立的github仓库的地址)
 5:输入代码 cd public (转到public这个仓库)
 6:输入代码 git init  (git基本操作）
 7:输入代码 git add .  (git基本操作）
 8:输入代码 git commit -m &amp;quot;taliantigertest&amp;quot; （把public文件提交到github上,其中&amp;quot;taliantigertest&amp;quot;可以自己填写，用作本次上传的标注文字）
 9:输入代码 git remote add origin https://github.com/taliantiger/taliantiger.github.io.git （把本地文件挂在远端）</description>
    </item>
    
    <item>
      <title>Second</title>
      <link>https://taliantiger.github.io/post3/second/</link>
      <pubDate>Fri, 27 Mar 2020 01:21:43 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/second/</guid>
      <description>This just a testing for my second blog published testing
I need to find out a way to save the problem of luanma with Chinese word.</description>
    </item>
    
    <item>
      <title>Welcome to Talian&#39;s blog</title>
      <link>https://taliantiger.github.io/post3/blog/</link>
      <pubDate>Wed, 25 Mar 2020 15:46:43 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/blog/</guid>
      <description>这是我的第一篇博客   个人邮箱：396318379@qq.com
  GitHub：https://github.com/Talian000001
  欢迎大家一同讨论计算机程序相关的问题
 下面的是一个图片添加尝试  论述如何在电脑本地git里，给github上传文件 1.创建好github文件库，打开文件库，出现文件库地址备用 2.接下来进行本地操作，在本地创建一个文件夹，右击，选择Git Bash Here,进入git界面 3.再然后，在界面输入如下代码，把github上的仓库克隆到本地 git clone https://github.com/Talian000001/photo.io （&amp;ldquo;https://github.com/Talian000001/photo.io&amp;quot;替换成你之前复制的地址）
4.执行完第3步后，你的本地项目文件夹下面会多出个文件夹，我们把本地项目下所有文件（新增加的文件夹不用）都移动到新增的文件夹下 5.接着输入命令 cd photo.io ，进入 photo.io 文件夹 6.再然后，一次输入如下代码 git add . (用于把photo文件夹下的文件都添加进来) git commit -m &amp;ldquo;abc&amp;rdquo; (相当于一次提交备注，所有这次提交地文件，都会有这个备注) git push -u origin master (把本地仓库push到github上，这个步骤要输入你的账号和密码) 教程来自：博客园 【持续更新中&amp;hellip;&amp;hellip;】 </description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Talian</title>
    <link>https://taliantiger.github.io/</link>
    <description>Recent content on Talian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 May 2020 22:18:51 +0800</lastBuildDate>
    
	<atom:link href="https://taliantiger.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Head_First_HTML</title>
      <link>https://taliantiger.github.io/post3/head_first_html/</link>
      <pubDate>Sat, 02 May 2020 22:18:51 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/head_first_html/</guid>
      <description>编写第一个HTLML文件  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Starbuzz Coffee&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Starbuzz coffee Beverages&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;House Blend, $1.49&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;A smooth, mild blend of coffees from mexico, Bolivia and Guatemala.&amp;lt;/p&amp;gt; &amp;lt;h2&amp;gt;Mocha Cafe Latte, $2.35&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Espresso, steamed milk and chocolate syrup.&amp;lt;/p&amp;gt; &amp;lt;h2&amp;gt;Cappuccino, $1.89&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;A mixture of espresso, Steamed milk and foam.&amp;lt;/p&amp;gt; &amp;lt;h2&amp;gt;chai Tea, $1.85&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;A spicy drink made with black tea, spices, milk and honey.&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; </description>
    </item>
    
    <item>
      <title>Leetcode习题_5</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_5/</link>
      <pubDate>Sat, 02 May 2020 14:36:15 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_5/</guid>
      <description>最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
输入: &amp;ldquo;babad&amp;rdquo; 输出: &amp;ldquo;bab&amp;rdquo; 注意: &amp;ldquo;aba&amp;rdquo; 也是一个有效答案。 示例 2：
输入: &amp;ldquo;cbbd&amp;rdquo; 输出: &amp;ldquo;bb&amp;rdquo;
 解决方法：中心扩散法 public class happy { public static void main (String[] args) { // System.out.println( longestPalindromel(&amp;#34;acdbbdaa&amp;#34;) ); 	System.out.println( longestPalindrome(&amp;#34;abbbbb&amp;#34;) ); } // 在默认的类里面添加方法 	// 中心扩展法动态规划。 	// 创建中心扩展方法 	public static String longestPalindrome(String s ) { // 用leetcode 提交时，对象的名字不能写错，不能写成longestPalindrome1，不然会提示符号错误==》对应名字不匹配，名字错误！！ 	// 判断s是不是空字符串或长度等于0 	if (s == null || s.</description>
    </item>
    
    <item>
      <title>十进制小数转为二进制</title>
      <link>https://taliantiger.github.io/post3/%E5%8D%81%E8%BF%9B%E5%88%B6%E5%B0%8F%E6%95%B0%E8%BD%AC%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6/</link>
      <pubDate>Fri, 01 May 2020 21:36:08 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E5%8D%81%E8%BF%9B%E5%88%B6%E5%B0%8F%E6%95%B0%E8%BD%AC%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6/</guid>
      <description>十进制小数转为二进制 十进制小数转换成二进制小数采用&amp;quot;乘2取整，顺序排列&amp;quot;法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。 然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。
0.425
0.425x2=0.85 =&amp;gt;取0
0.85x2=1.7 =&amp;gt;取1
0.7x2=1.4 =&amp;gt;取1
0.4x2=0.8 =&amp;gt;取0
0.8x2=1.6 =&amp;gt;取1
0.6x2=1.2 =&amp;gt;取1
&amp;hellip;. （取前6位=&amp;gt;011011B,后面还会循环下去)
0.425=011011B
不都是无限循环，如0.5=0.1B
   小数部分处理方式:小数部分乘2再取整,直到小数部分乘2结果等于1.
特点:小数部分先取的得到的数字,靠经小数点&amp;rdquo;.&amp;quot;;
  整数部分处理方式:整数部分除以2取余数.不断循环,直到最后除以2后得到的商,等于0.
特点:类似于小数部分,先得到的余数(低位数字),也更靠近小数点&amp;rdquo;.&amp;rdquo;
   参考来自:
百度知道-十进制的小数部分怎么转为二进制
知乎-十进制二进制的转换</description>
    </item>
    
    <item>
      <title>现实中的西部世界</title>
      <link>https://taliantiger.github.io/post3/%E7%8E%B0%E5%AE%9E%E4%B8%AD%E7%9A%84%E8%A5%BF%E9%83%A8%E4%B8%96%E7%95%8C/</link>
      <pubDate>Tue, 28 Apr 2020 21:11:36 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E7%8E%B0%E5%AE%9E%E4%B8%AD%E7%9A%84%E8%A5%BF%E9%83%A8%E4%B8%96%E7%95%8C/</guid>
      <description>现实中的西部世界 你怀疑过自己的记忆吗？
 西部世界第三季里的男主，过着普通建筑工人的生活， 直到有一天Delores带他寻找到自己的记忆，发现自己记忆中的战友战死，原来是被自己杀死；看似反抗社会的“滴滴打劫”， 原来也是被“所罗门”控制的，一切都是为了清除“离群人”。为什么我们每天都做着同样的事，有些错误经常犯，自己本身自制力是一方面， “社会安排”也是一方面，穷人过着穷人轨迹，富人过着富人轨迹，一直都被这个社会的大集体所“安排着”。
 做出极大的改变，有Delores那样的“领路人”，才能真正改变一个人的轨迹， 才能真正改变自身的生活习惯，改变这个社会强加给人类的思维方式。人活着总要吸取教训，并真正记下教训，拥有属于自己的真实记忆，而不是这次犯了错，“洗脑”， 下次接着犯错，再洗脑&amp;hellip;..Caleb是曾经的Delores,现实世界是曾经的西部世界，机器人能够有意识并觉醒，人类是决定让自己被困在这个社会创造的Host里， 走社会和机器写好的老路径；还是夺回自己的掌控权，让自己的记忆，被自己主宰，让自己的人生由自己掌握？
 You ever ask yourself any question? Like how you wound up with the exact same job.</description>
    </item>
    
    <item>
      <title>愚昧贫穷人的本质</title>
      <link>https://taliantiger.github.io/post3/%E6%84%9A%E6%98%A7%E8%B4%AB%E7%A9%B7%E4%BA%BA%E7%9A%84%E6%9C%AC%E8%B4%A8/</link>
      <pubDate>Tue, 28 Apr 2020 10:42:17 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E6%84%9A%E6%98%A7%E8%B4%AB%E7%A9%B7%E4%BA%BA%E7%9A%84%E6%9C%AC%E8%B4%A8/</guid>
      <description>永远不要相信愚昧的穷人   能不和穷人相处就不和愚昧穷人相处，哪怕自己一个人独处也好，不要对他们付出时间和精力，不然只是恶心自己。
  愚昧的穷人永远不可能有所本质的改变，你永远无法相信愚昧的穷人会做出什么事情来恶心干涉你的生活。
  愚昧的穷人，不但物质贫穷，知识和精神也贫穷，爱贪一点小便宜，不明白事物的本质，思维上无法有所提高，只能任人宰割， 或恶心其他人。
  愚昧使人贫穷，贫穷使人愚昧，不断恶性循环，愚昧的穷人如果能有所改变，就不是愚昧的穷人，但基本上愚昧的穷人会愚昧贫穷一辈子。
  </description>
    </item>
    
    <item>
      <title>疯狂Java讲义_6_7</title>
      <link>https://taliantiger.github.io/post3/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89_6_7/</link>
      <pubDate>Mon, 27 Apr 2020 09:47:34 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89_6_7/</guid>
      <description>非静态内部类 （一）内部实例方法访问外部pravate变量
 下面程序在Cow类里定义了一个CowLeg非静态内部类， 并在CowLeg类的实例方法中直接访问Cow的private访问权限的实例变量。(private:只有当前类可见)
 public class Cow { private double weight; // 外部类的两个重载的构造器 	public Cow() {} public Cow(double weight) { this.weight = weight; } // 定义一个非静态内部类,专门研究奶你腿 	// private class Cowleg 	private class CowLeg // 注意一个字母不单单开头可能要大写，中间也可能要大写。不然报错：Cow.java:19: 错误: 方法声明无效; 需要返回类型 ==》 可能就是方法或类的名字写错了。 	{ // 非静态内部类的两个实例变量 	private double length; private String color ; // 非静态内部类的两个重载器 	public CowLeg() {} public CowLeg(double length, String color) { this.length = length; this.</description>
    </item>
    
    <item>
      <title>疯狂Java讲义_6</title>
      <link>https://taliantiger.github.io/post3/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89_06/</link>
      <pubDate>Sat, 25 Apr 2020 23:04:26 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89_06/</guid>
      <description>疯狂Java讲义   实现(implements)：类似于“多继承”。
  接口：当说PCI接口时，指的是主机板上那个插槽遵守了PCI规范，而具体的PCI插槽只是PCI接口的实例。
  构造器：（1）构造器名字和类名相同。
（2）无返回值，也无需void。 （3）用public、protect、privated修饰，或无修饰。
  </description>
    </item>
    
    <item>
      <title>疯狂Java讲义_6_1</title>
      <link>https://taliantiger.github.io/post3/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89_6_1/</link>
      <pubDate>Thu, 23 Apr 2020 23:49:45 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89_6_1/</guid>
      <description>疯狂Java讲义_6.1  包装类的由来： 基本数据类型不具备对象的特性:没成员变量、方法可以被调用。Java之所以提供这8种基本数据类型，主要是为了照顾程序员的传统习惯。Java提供了包装类（Wrapper Class）的概念，为8种基本数据类型分别定义了相应的引用类型，并称之为包装类。对应关系之间，可以相互转换。  从而产生了自动装箱、自动拆箱的概念。
 自动装箱:把一个基本类型变量直接赋给对应的包装类变量，或赋给Object变量。==》把小的基本东西放大大的类型东西里。 自动拆箱：和自动装箱相反，允许直接把包装类对象直接赋给一个对应的基本数据类型。==》把大的类型东西拆开，取出小的基本东西。   public class AutoBoxingUnboxing { public static void main(String[] args) { // 自动装箱： 直接把一个基本类型变量赋给Integer对象 	Integer inObj = 5; // 直接把一个boolean类型变量赋给Object类型的额变量 	Object boolObj = true; // 自动拆箱：直接把一个Integer对象赋给int类型的变量 	int it = inObj; if (boolObj instanceof Boolean) { // 先把Object对象强制类型转换成Boolean类型，再赋给 boolean 变量 	boolean b = (Boolean) boolObj; System.out.println(b); } } } </description>
    </item>
    
    <item>
      <title>衡量中产阶级</title>
      <link>https://taliantiger.github.io/post3/%E8%A1%A1%E9%87%8F%E4%B8%AD%E4%BA%A7%E9%98%B6%E7%BA%A7/</link>
      <pubDate>Tue, 21 Apr 2020 23:06:39 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E8%A1%A1%E9%87%8F%E4%B8%AD%E4%BA%A7%E9%98%B6%E7%BA%A7/</guid>
      <description>衡量中产阶级  衡量一个人，一个家庭是否处于中产阶级的一个重要标志， 应该是能否在不工作的情况下，能独立正常地处理好日常生活地事物。
 当我们遭遇突发状况时，储蓄状况如何， 除工作经济收入外，是否还有其他地经济收入？纵观自己的家庭，当家里长辈可能要住院时， 真没几个人能果断放下工作，以长辈健康为根本，来自愿自愿照顾老人的，毕竟家里人大部分都是普通人， 都有工作，要养活自己或照顾小孩。
 如果有足够的除工作外的收入， 那我们的生活才可以说有足够保障。可是现实是，生活中大部分都是普通人， 只能靠工作来养活自己，养活家庭。
 但是也不用太悲观，发现问题，总比隐藏住问题好。 我们至少可以有危机意识，未雨绸缪。这也是我们要尽可能养成储蓄和投资习惯，不要做“月光族”的原因。 多一份保障，给自己多一份安全感，让未来的日子更好过。程序员也如此，迟早都有中年危机， 年轻时多谋几条出路，多做好准备，总是好些。</description>
    </item>
    
    <item>
      <title>疯狂Java讲义</title>
      <link>https://taliantiger.github.io/post3/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89/</link>
      <pubDate>Sat, 18 Apr 2020 21:14:09 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89/</guid>
      <description>疯狂 Java讲义  第五章  Java编程时不要使用对象去调用static修饰的成员变量、方法， 而是应该使用类去调用static修饰的成员变量、方法!</description>
    </item>
    
    <item>
      <title>波士顿法律</title>
      <link>https://taliantiger.github.io/post3/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E6%B3%95%E5%BE%8B/</link>
      <pubDate>Fri, 17 Apr 2020 12:47:15 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E6%B3%95%E5%BE%8B/</guid>
      <description>波士顿法律 一边同流合污，一边愤世嫉俗。
 在《波士顿法律》里，美国的法律挺有意思的，同一件事，看待问题的角度不同， 得到解答结果也不同。欠了信用卡的钱，逾期后，信用卡的利息高达百分之30，但是通过主角的能言善道， 让信用卡公司把账单一笔勾销，这还是在2003年发生的事。回看现在，花呗和其他信用卡表面一年收的利息金额是总借款的百分之15左右， 但是这账单还款时按月还款的，并不是一年的最后一次性付清的。实际的利率，差不多也会达到百分之30。同样的套路，十几年存在， 现在也依然存在。
 就如同现实生活中的很多谎言，绝对的谎言欺骗类的已经很少了， 更多的是隐瞒事实，不说出事物的本质，达到个人或团体的利益。因此如半佛老师的调侃挺有意思的， “免费的东西往往是最贵的，其他人不会免费给你东西，除非想想，这个人有没可能是你失散多年的父亲。 想想他这样做的动机是什么，是什么决定他会这样做。”
 知乎也是这样，站在看待问题的角度不同，得出的结论也有很大不同， 会有很多分歧争吵。同样是面对英雄联盟，loser可以把他当作逃离现实生活，满足自己地位幻想的需要； 也可以只把他当作普通的单机游戏，打人机模式来玩。现实生活中也有很多真正对自己身体生活有益的事情可做， 看风景处处都是1080p，在现实生活的运动和美景，它不香吗？
 面对问题时，尝试从多个角度去看待问题。 不同人有不同动机，看待问题角度自然不同。多变换几个角度，也挺有意思的。 人生，总不能一直这么枯燥，总是有些乐趣的。编程也同样。
 </description>
    </item>
    
    <item>
      <title>程序员的自我修养_1</title>
      <link>https://taliantiger.github.io/post3/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</link>
      <pubDate>Wed, 15 Apr 2020 22:35:48 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</guid>
      <description>程序员的自我修养_1  程序员进行程序开发时，不要仅仅停留在代码表面，而要深入底层的运行机制， 才可以对程序的运行有更准确的把握。   看待一个数组时，一定要把数组看成两个部分： 一部分是数组引用，也就是在代码中定义的数组引用变量；还有一部分是实际的数组对象， 这部分是在堆内存里运行的，通常无法直接访问它，只能通过数组引用变量来访问。
 栈内存（或叫内存栈）：只是一个栈，里面存储内存变量。
堆内存：一堆一堆的，里面存储对象，像一个池塘样的大圆。</description>
    </item>
    
    <item>
      <title>英雄联盟成瘾机制</title>
      <link>https://taliantiger.github.io/post3/%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%88%90%E7%98%BE%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 12 Apr 2020 18:39:26 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%88%90%E7%98%BE%E6%9C%BA%E5%88%B6/</guid>
      <description>英雄联盟成瘾机制 现实中药经历磨难才更可能获得成就，而在英雄联盟中，只需要苦练就可获得成就
 上个星期，英雄联盟有个活动，打pvp模式可以获得游戏里的“代币”， “代币”可以兑换游戏里的新英雄，于是呼，我决定开始打排位，一边获得代币奖励，感觉也挺不错，很快拥很多的英雄了。 可是渐渐地玩着玩着，就越来越想玩，赢了想要获得更多胜利，想下一盘获得更多的“代币”；输了觉得不服气，想下一局再努力 下，扳回排位积分颜面。就这样，每天沉浸其中。同样的事情在大学期间不止发生过一两次，有多次重复。可我依旧无法吸取教训。 今天在知乎查找其中的本质，有人回答得好的。日常生活中，最电视剧，追动漫 同样会令人上瘾，但与英雄联盟比起来，这种成瘾性就如吸烟和吸毒的区别，电视剧、动漫，不论情节如何紧凑，也无法一直 刺激观众的神经，但英雄联盟不同，它每时每刻都在向玩家的脑子里发送一阵阵脉冲，不停地激励玩家的神经，让玩家亢奋不已。 令人上瘾的电视剧动漫都有好的剧本，好的故事。但在英雄联盟里，表面上看起来所有故事都是玩家自己一手导演的，其实剧本 早就死死攥在拳头公司手里了。
 游戏设计者很聪明的加入了20分钟投降的规则，来冲抵失败带来的挫败感， 让玩家将这场失利归因于非己因素，如队友太菜，对手太强，并相信这场失利只是一个偶然事件，而忽视自身实力在游戏中起到 的关键作用，从而寄希望于下一场比赛，而不是因失败产生气馁情绪或索性放弃这个游戏。此外，游戏的匹配机制使得每场对战 的玩家之间的水平差距很小，高手虐菜——这种即使胜利愉悦感也很小但失败方挫败感极强的情况几乎不会出现，游戏的可玩性大 大提高。综上，这款游戏的净愉悦是大于0的，所以随着游戏局数的不断增加，这种愉悦将同步增加，从而取悦越来越多的老玩 家，吸纳越来越多的新玩家。
 最后是游戏建立的一个庞大人类社会阶层，给玩家更多的游戏激励和刺激。 换个角度想的话，英雄联盟其实是人类社会的一个缩影，游戏中的庞大英雄库和人类不同种族和民族；英雄各具技能和每个人的 掌握的不同知识和技术；5人团队不同的位置分工和人类团队中的劳动分工。更难得的是，游戏建立了排位机制，将玩家按照游 戏技术分为不同的大段，在每个大段中还有小段。段位是会伴随玩家的每场比赛出现在比赛信息中的，算是玩家被贴上的社会标 签，一定程度上可以反映玩家的游戏实力。这种显性的标签当玩家自己认为自身实力与自己的段位不匹配时会产生一种激励，让 玩家为了取得更高的地位而争取比赛胜利，从而可以得到段位的提升。这与人们为了取得更高社会地位所做的努力多么相似。同 时，因为游戏是非输即赢，一位玩家段位提高，也就意味着另一位玩家段位降低。这种排他性的竞争更能给人带来成就感。而且 ，相比于在现实生活中历经磨难获得更高社会地位从而获得人们尊重，在游戏中刻苦练习而得到更高段位要容易得多。这也是为 什么很多现实生活中得loser会如此沉迷于这款游戏的原因，在游戏中能获得不低的身份认同却又不用付出那么多努力，何乐而 不为呢？而在现实生活中，loser的数量要远远大于winner的数量，英雄联盟给了他们释放情绪的空间。对游戏开发者来说，新 玩家数量激增怎么办？增开个服务器就可以了，而在现实中，增加一个可供竞争的行业可不是那么容易。所以相比于现实生活， 英雄联盟给了loser们充足的精神空间，无穷无尽的空间。
   英雄联盟时刻刺激玩家神经，让玩家亢奋不已
  设计游戏规则，寄希望于下一场比赛。
  现实中经历磨难获得更高的社会地位而获得人们的尊重，在游戏中刻苦训而获得更高段位要容易得多
   转自英雄联盟成瘾机制</description>
    </item>
    
    <item>
      <title>Python_9 6例题</title>
      <link>https://taliantiger.github.io/post3/python_9-6%E4%BE%8B%E9%A2%98/</link>
      <pubDate>Fri, 03 Apr 2020 20:54:16 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/python_9-6%E4%BE%8B%E9%A2%98/</guid>
      <description>冰激凌小店  9-6冰淇淋小店:冰淇淋小店是一种特殊的餐馆。编写一个名为IceCreamstand的类,让它继承你为完成 练习9-1或练习9-4而编写的Restaurant类。这两个版本的Restaurant类都可以,挑选你更喜欢的那个即可。 添加一个名为flavors的属性,用于存储一个由各种口味的冰淇淋组成的列表。编写一个显示这些冰淇淋的方法。 创建一个IceCreamstand 实例，并调用这个方法。   class Restaurant(): #定义一个类 def __init__(self,restaurant_name,cuisine_type): #记住这里__init__的下划线是左右各两条__，而不是一条_ self.restaurant_name = restaurant_name self.cuisine_type = cuisine_type self.number_served = 0 #特殊方法下面的选项开头之前，都要添加“self”，代表默认 def describe_restaurant(self): print(self.restaurant_name.title() + &amp;#34; is a very good restaurant.&amp;#34;) print(self.cuisine_type.title() + &amp;#34; is very tasty food for most people.&amp;#34;) def open_restaurant(self): #不知道为什么，复制粘贴过来就出错 ==&amp;gt;复制到之前的地方，对比下，就很明显，发现： “语法错误”，第9行复制过来后，没发现，print结尾少了括号。 print(&amp;#34;Our restaurant is opening&amp;#34;) def read_number_served(self):	#打印一条支出多少人用餐的消息 print(&amp;#34;This restaurant has &amp;#34; + str(self.number_served) + &amp;#34; person will eat food.&amp;#34;) def set_number_served(self,renshu) : #通过方法设置就餐人数 self.</description>
    </item>
    
    <item>
      <title>正确的刷牙方法</title>
      <link>https://taliantiger.github.io/post3/%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%88%B7%E7%89%99%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 01 Apr 2020 09:56:11 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%88%B7%E7%89%99%E6%96%B9%E6%B3%95/</guid>
      <description>正确的刷牙方法  一个月前吃橘子的时候，橘子比较酸，但没有在意，等吃了很多个时，忽然觉得牙齿 一阵酸痛，用镜子看了看牙齿，发现左边的一颗牙龈比右边对称的牙龈萎缩了些，牙齿多露出了1.5毫米，用手一碰 露出的牙齿，就会一阵酸痛，当时以为是橘子腐蚀了，就一直不再吃橘子，但也没有深究。
 昨天突发奇想，查了查知乎牙龈萎缩相关资料，发现大部分观点是牙龈萎缩后基本 无法复原了，除做昂贵的手术或用其它物体把露出的牙齿粘上。再接着找资料，寻找牙龈萎缩的原因，发现自己的刷牙 方法从小就不太规范，虽然会斜着刷，但用的力度太大，以前经常刷牙刷出血&amp;hellip;&amp;hellip;没有完全按照巴氏刷牙法执行。同时我从大学开始， 牙刷就用的是中毛，可中毛和硬毛对牙龈有比较重的损伤，用软毛才比较合适。
 如果再不用正确的刷牙方法刷牙，估计就是严重的牙齿楔形，很难再修复了， 我的一颗牙齿已经有点楔形了，保护牙齿，还是早发现，早纠正。现实生活上也仿佛如此，表面上平平 安安，健康无事，但是很多风险与疾病就隐藏在暗处，真正的危险，往往也都是藏在暗处，就连国家，都无法 提前知道疾病会爆发，只能在疫情爆发后解决问题。我们有时也无法发现生活中所有的风险，能做的，只能是 在风险出现时，及时调整解决。虽然牙齿萎缩，很难恢复，但是从发现问题开始，好好好珍惜尚存完好的牙齿， 采取正确的刷牙方法，不让萎缩的牙齿接着严重下去，才是我当下要关注的事。
 给岁月以文明，而不是给文明以岁月。给牙齿恰当的保护，而不是损坏时的手术。
 牙齿楔形
正确刷牙法</description>
    </item>
    
    <item>
      <title>Leetcode例题_05</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_05/</link>
      <pubDate>Wed, 01 Apr 2020 09:48:03 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_05/</guid>
      <description>最长回文子串   给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
输入: &amp;ldquo;babad&amp;rdquo; 输出: &amp;ldquo;bab&amp;rdquo; 注意: &amp;ldquo;aba&amp;rdquo; 也是一个有效答案。
示例 2：
输入: &amp;ldquo;cbbd&amp;rdquo; 输出: &amp;ldquo;bb&amp;rdquo;
   Python  基础暴力解法（有待研究）：  class Solution: # 暴力匹配（超时） def longestPalindrome(self, s: str) -&amp;gt; str: # 特判 size = len(s) if size &amp;lt; 2: return s max_len = 1 res = s[0] # 枚举所有长度大于等于 2 的子串 for i in range(size - 1): for j in range(i + 1, size): if j - i + 1 &amp;gt; max_len and self.</description>
    </item>
    
    <item>
      <title>Leetcode习题_04</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_04/</link>
      <pubDate>Tue, 31 Mar 2020 11:17:34 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_04/</guid>
      <description>寻找两个有序数组的中位数:   给定两个大小为m和n的有序数组 nums1 和 nums2 。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。   Python 想起之前书中例题，于是尝试：  利用pop( )语句，把nums2列表末尾元素“吹”出来； 再利用append() 语句，把列表元素“压”回到nums1[]中。 利用list.sort()排序。 再判断元素总个数的奇偶情况，分不同情况取中位数即可。  class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&amp;gt; float:	def paixu(nums1,nums2): while nums2: a = nums2.pop() nums1.append(a) nums1.sort() return nums1 def test_length(nums1): len_1 = len(nums1) return len_1 def panduanshu(nums1,len_1): middle = len_1//2 if (len_1%2==0): result = (nums1[middle] + nums1[middle-1])/2 else : result = nums1[middle] return result #nums1=paixu(nums1,nums2) #len_1=test_length(nums1) #result=panduanshu(nums1,len_1) return panduanshu(nums1,test_length(paixu(nums1,nums2))) #尝试不定义变量，直接嵌套调用,发现复杂的没变化。 </description>
    </item>
    
    <item>
      <title>Java学习,何时开始使用IDE工具</title>
      <link>https://taliantiger.github.io/post3/java%E5%AD%A6%E4%B9%A0%E4%BD%95%E6%97%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8ide%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 30 Mar 2020 22:49:29 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/java%E5%AD%A6%E4%B9%A0%E4%BD%95%E6%97%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8ide%E5%B7%A5%E5%85%B7/</guid>
      <description>Java学习，何时开始使用IDE工具呢？  标准是：如果你还离不开这个IDE工具，那么你就不能用这个IDE工具;只有 当你十分清楚再IDE工具里单击每一个菜单，单击每一个按钮&amp;hellip;&amp;hellip;IDE在底层 为你做的每个细节时，才可以使用IDE工具！  选自《疯狂Java讲义》
 仔细想想，挺有道理的，要想成为一名合格的程序员，我们必须要清楚地知道 软件每一步在细节上到底做了什么，知道事物的本质，才能更好的创造。就像 《三体》一样，看哪个文明的更厉害，就看哪个文明在微观之处研究得更深入 ，研究越细，越能了解事物得本质，创造更厉害得本质。
今天刚读完这本《疯狂Java讲义》第一章， 在第一章提到了很多Java运行的细节: “编写” xxx.java 文件=》 javac 命令 “编译”.java文件，生成 xxx.class （类文件）=》 java 命令 “运行” xxx （类的名字）　．．．之类的运行步骤。还有classpath环境变量设置的 本质就是————JRE在设定的路径下搜索Java类。</description>
    </item>
    
    <item>
      <title>Leetcode习题_03</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_03/</link>
      <pubDate>Mon, 30 Mar 2020 12:53:00 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_03/</guid>
      <description>无重复字符的最长子串   给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: &amp;ldquo;abcabcbb&amp;rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。
   Python:  解题方法：利用动态规划求解:把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解  class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: if s == &amp;#39;&amp;#39;: return 0 if len(s) == 1: return 1 def find_left(s, i): tmp_str = s[i] j = i - 1 while j &amp;gt;= 0 and s[j] not in tmp_str: tmp_str += s[j] j -= 1 return len(tmp_str) length = 0 for i in range(0, len(s)): length = max(length, find_left(s, i)) return length  来源：leetcode</description>
    </item>
    
    <item>
      <title>Python_9_4例题</title>
      <link>https://taliantiger.github.io/post3/python_9_4%E4%BE%8B%E9%A2%98/</link>
      <pubDate>Sun, 29 Mar 2020 22:54:55 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/python_9_4%E4%BE%8B%E9%A2%98/</guid>
      <description>又到周日了，仔细算算，看《python编程从入门到实践》学python已经有半个月了，还有2/3没看完，打算以后周五周末周日再看了。前天我的 《疯狂Java讲义》和《剑指offer》到了，打算工作日都主要研究Java为主，先把Java基础打好，才有更强大的工作资本。    9_4 就餐人数：
在为完成练习1胜9负而编写的程序中,添加一个名为服务数量的属性,并将其默认值设置为0,根据这个类创建一个名为 餐厅的实例;打印有多少人在这家餐馆就餐过,然后修改这个值并再次打印它。
添加一个名为设置数量为()的方法,它让你能够设置就餐人数。调用这个方法并向它传递一个值,然后再次打印这个值。
添加一个名为增加数量为()的方法,它让你能够将就餐人数递增。调用这个方法并向它传递一个这样的值:你认为这家餐馆每天可能接待的就餐人数。   class Restaurant(): #定义一个类 def __init__(self,restaurant_name,cuisine_type): #记住这里__init__的下划线是左右各两条__，而不是一条_ self.restaurant_name = restaurant_name self.cuisine_type = cuisine_type self.number_served = 0 #特殊方法下面的选项开头之前，都要添加“self”，代表默认 def describe_restaurant(self): print(self.restaurant_name.title() + &amp;#34; is a very good restaurant.&amp;#34;) print(self.cuisine_type.title() + &amp;#34; is very tasty food for most people.&amp;#34;) def open_restaurant(self): #不知道为什么，复制粘贴过来就出错 ==&amp;gt;复制到之前的地方，对比下，就很明显，发现： “语法错误”，第9行复制过来后，没发现，print结尾少了括号。 print(&amp;#34;Our restaurant is opening&amp;#34;) def read_number_served(self):	#打印一条支出多少人用餐的消息 print(&amp;#34;This restaurant has &amp;#34; + str(self.number_served) + &amp;#34; person will eat food.</description>
    </item>
    
    <item>
      <title>Leetcode习题_02</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_02/</link>
      <pubDate>Sun, 29 Mar 2020 10:57:59 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_02/</guid>
      <description>两数之和_02   给定两个 非空 链表来表示两个非负整数。位数按照 逆序 方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。
你可以假设除了数字 0 之外，这两个数字都不会以零开头。
示例：
输入： (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) 输出： 7 -&amp;gt; 0 -&amp;gt; 8 原因： 342 + 465 = 807
   Java:  public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q !</description>
    </item>
    
    <item>
      <title>多个实参输入一个形参中</title>
      <link>https://taliantiger.github.io/post3/%E5%A4%9A%E4%B8%AA%E5%AE%9E%E5%8F%82%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%BD%A2%E5%8F%82/</link>
      <pubDate>Sat, 28 Mar 2020 17:46:13 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E5%A4%9A%E4%B8%AA%E5%AE%9E%E5%8F%82%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%BD%A2%E5%8F%82/</guid>
      <description> 8-12 三明治：编写一个函数，它接受顾客要在三明治中添加的一系列食材 这函数只有一个形参(它收集函数调用中提供的所有食材),并打印一条消 息，对顾客雨酌三明治进行概述。调用这个函数三次，每次都提供不同数量的实参    函数注意事项：函数调用的多个形参，必须是一系列字符串元素，而不能是自己定义的列表变量！！   def accept_food( *somefood ):for somefood_1 in somefood :print(&amp;#34;- &amp;#34; + somefood_1)print(&amp;#39;\n&amp;#39;)accept_food(&amp;#39;a&amp;#39;) #函数这里调用的形参，必须是字符串元素，而不能是自己定义的列表变量！！ accept_food(&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;)accept_food(&amp;#39;d&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;f&amp;#39;)# ~ def make_pizza(*toppings):  # ~ print(&amp;#34;\nMaking a pizza with the following toppings:&amp;#34;)  # ~ for topping in toppings:  # ~ print(&amp;#34;- &amp;#34; + topping)  # ~ make_pizza(&amp;#39;pepperoni&amp;#39;)  # ~ make_pizza(&amp;#39;mushrooms&amp;#39;, &amp;#39;green peppers&amp;#39;, &amp;#39;extra cheese&amp;#39;) </description>
    </item>
    
    <item>
      <title>python:利用切片禁止函数修改列表</title>
      <link>https://taliantiger.github.io/post3/%E5%88%A9%E7%94%A8%E5%88%87%E7%89%87%E7%A6%81%E6%AD%A2%E5%87%BD%E6%95%B0%E4%BF%AE%E6%94%B9%E5%88%97%E8%A1%A8/</link>
      <pubDate>Sat, 28 Mar 2020 16:44:34 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/%E5%88%A9%E7%94%A8%E5%88%87%E7%89%87%E7%A6%81%E6%AD%A2%E5%87%BD%E6%95%B0%E4%BF%AE%E6%94%B9%E5%88%97%E8%A1%A8/</guid>
      <description> 8-11不变的魔术师:修改你为完成练习8-10而编写的程序,在调用函数make great()时,向它传递魔术师列表的副本。由于 不想修改原始列表, 请返回修改后的列表，并将其存储到另一个列表中。分别使用这两个列表来调用showmagicians(),确认一个列表包含的是原来的魔木师名字,而另一个列表包含的是添加了字样&amp;quot;theGreat&amp;quot;的魔术师名字。   函数核心关键:在调用函数输出时，函数的实参末尾加上切片 [:] ,相当于为函数创建了副本，这样函数原本的列表值就不会被改变了。  #定义“显示具体打印过程”的函数 ==》在函数中修改列表的模板 def print_magicians(unprinted_magicians_names,completed_magicians): while unprinted_magicians_names: current_magician = unprinted_magicians_names.pop() #每打印完一个，除去掉“未打印列表”中的一个元素 print(&amp;#34;Printing magicians: &amp;#34; + current_magician) completed_magicians.append(current_magician) #每打完一个，就把被打印的append保存在之前的空列表中 #定义“显示打印结果”的函数 def show_completed_magicians(completed_magicians): print(&amp;#34;\nThe following magicians have been printed:&amp;#34;) for completed_magician in completed_magicians: print(completed_magician) def make_great(completed_magicians,completed_magicians_2): print(&amp;#34;\nThe following magicians is new&amp;#34;) while completed_magicians: current_magician_2=&amp;#34;the Great &amp;#34; + completed_magicians.pop() #类似重复第一个函数，pop一个函数的列表，加入另外一个函数的列表 completed_magicians_2.append(current_magician_2) for completed_magician_2 in completed_magicians_2: print(completed_magician_2) unprinted_magicians_names=[&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;D&amp;#39;] completed_magicians=[] completed_magicians_2=[] print_magicians(unprinted_magicians_names[:],completed_magicians) #调用函数时，在实参这里添加 切片[:] ，就可以达到调用副本的目的 show_completed_magicians(completed_magicians) make_great(completed_magicians,completed_magicians_2) print(completed_magicians_2) #显示出添加“the Great” 后的结果 print(unprinted_magicians_names) </description>
    </item>
    
    <item>
      <title>《python编程从入门到实践》8_10例题</title>
      <link>https://taliantiger.github.io/post3/python_8_10%E4%BE%8B%E9%A2%98/</link>
      <pubDate>Sat, 28 Mar 2020 15:49:10 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/python_8_10%E4%BE%8B%E9%A2%98/</guid>
      <description>##《python编程从入门到实践》例题
 8-9 魔术师： 创建一个包含魔术师名字的列表，并将其传递给一个名为 show_magicians() 的函数，这个函数打印列表中每个函数的名字 8-10 了不起的魔术师：在你为完成练习 8—9 而编写的程序中，编写一个名为make_great()的函数，对魔术师列表进行修改，在每个魔术师的名字中都加入字样： the Great“。 调用函数show_magician,确认列表确实变了   构造函数关键: 函数（形参A，形参B），把形参A的列表pop出，再append到形参B的列表  def print_magicians(unprinted_magicians_names,completed_magicians): #定义“显示具体打印过程”的函数 ==》在函数中修改列表的模板 while unprinted_magicians_names: current_magician = unprinted_magicians_names.pop() #每打印完一个，除去掉“未打印列表”中的一个元素 print(&amp;#34;Printing magicians: &amp;#34; + current_magician) completed_magicians.append(current_magician) #每打完一个，就把被打印的append保存在之前的空列表中 #定义“显示打印结果”的函数 def show_completed_magicians(completed_magicians): print(&amp;#34;\nThe following magicians have been printed:&amp;#34;) for completed_magician in completed_magicians: print(completed_magician) def make_great(completed_magicians,completed_magicians_2): print(&amp;#34;\nThe following magicians is new&amp;#34;) while completed_magicians: current_magician_2=&amp;#34;the Great &amp;#34; + completed_magicians.pop() #类似重复第一个函数，pop一个函数的列表，加入另外一个函数的列表 completed_magicians_2.append(current_magician_2) for completed_magician_2 in completed_magicians_2: print(completed_magician_2) unprinted_magicians_names=[&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;D&amp;#39;] completed_magicians=[] completed_magicians_2=[] print_magicians(unprinted_magicians_names,completed_magicians) show_completed_magicians(completed_magicians) make_great(completed_magicians,completed_magicians_2) print(completed_magicians_2) #显示出添加“the Great” 后的结果 </description>
    </item>
    
    <item>
      <title>Leetcode习题_01</title>
      <link>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_01/</link>
      <pubDate>Sat, 28 Mar 2020 08:59:32 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/leetcode%E4%B9%A0%E9%A2%98_01/</guid>
      <description>1.两数之和   给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
  你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
  示例:
给定 nums = [2, 7, 11, 15], target = 9,因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1]
   方法一:暴力法 遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。
Java:
class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i &amp;lt; nums.length; i++) { for (int j = i + 1; j &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>Hugo建立博客用到的代码</title>
      <link>https://taliantiger.github.io/post3/hugo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%88%B0%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 27 Mar 2020 13:36:13 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/hugo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E7%94%A8%E5%88%B0%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
      <description>hugo建立博客用到的代码   前几天看了b站的程序羊的教学视频，学会了搭建个人博客。配置完git和hugo环境后，用到了很多git命令，现在在这里把后几步的git命令记录在这篇博客当中  建立好hugo和git环境后的前提下,在cmd中 1:输入代码 hugo new site myblog3 (myblog3是我自己的命名的一个例子)
 2:输入代码 git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c (这里的theme主题可以自己在网站上找，我这里是程序羊推荐的)
再输入代码 hugo server -t m10c --buildDrafts（在本地host先建立博客）
 3:输入代码 hugo new post3/blog3.md (创建 文件夹post（自己命名），同时在建立博客.md文件（blog3也是自己命名的）)
 4:输入代码 hugo --theme=m10c --baseUrl=&amp;quot;https://taliantiger.github.io/&amp;quot; --buildDrafts(用于建立public文件，其中&amp;quot;https://taliantiger.github.io/&amp;ldquo;填写你是自己之前建立的github仓库的地址)
 5:输入代码 cd public (转到public这个仓库)
 6:输入代码 git init  (git基本操作）
 7:输入代码 git add .  (git基本操作）
 8:输入代码 git commit -m &amp;quot;taliantigertest&amp;quot; （把public文件提交到github上,其中&amp;quot;taliantigertest&amp;quot;可以自己填写，用作本次上传的标注文字）
 9:输入代码 git remote add origin https://github.com/taliantiger/taliantiger.github.io.git （把本地文件挂在远端）</description>
    </item>
    
    <item>
      <title>Second</title>
      <link>https://taliantiger.github.io/post3/second/</link>
      <pubDate>Fri, 27 Mar 2020 01:21:43 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/second/</guid>
      <description>This just a testing for my second blog published testing
I need to find out a way to save the problem of luanma with Chinese word.</description>
    </item>
    
    <item>
      <title>Welcome to Talian&#39;s blog</title>
      <link>https://taliantiger.github.io/post3/blog/</link>
      <pubDate>Wed, 25 Mar 2020 15:46:43 +0800</pubDate>
      
      <guid>https://taliantiger.github.io/post3/blog/</guid>
      <description>这是我的第一篇博客   个人邮箱：396318379@qq.com
  GitHub：https://github.com/Talian000001
  欢迎大家一同讨论计算机程序相关的问题
 下面的是一个图片添加尝试  论述如何在电脑本地git里，给github上传文件 1.创建好github文件库，打开文件库，出现文件库地址备用 2.接下来进行本地操作，在本地创建一个文件夹，右击，选择Git Bash Here,进入git界面 3.再然后，在界面输入如下代码，把github上的仓库克隆到本地 git clone https://github.com/Talian000001/photo.io （&amp;ldquo;https://github.com/Talian000001/photo.io&amp;quot;替换成你之前复制的地址）
4.执行完第3步后，你的本地项目文件夹下面会多出个文件夹，我们把本地项目下所有文件（新增加的文件夹不用）都移动到新增的文件夹下 5.接着输入命令 cd photo.io ，进入 photo.io 文件夹 6.再然后，一次输入如下代码 git add . (用于把photo文件夹下的文件都添加进来) git commit -m &amp;ldquo;abc&amp;rdquo; (相当于一次提交备注，所有这次提交地文件，都会有这个备注) git push -u origin master (把本地仓库push到github上，这个步骤要输入你的账号和密码) 教程来自：博客园 【持续更新中&amp;hellip;&amp;hellip;】 </description>
    </item>
    
  </channel>
</rss>